<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qtbinding.qdoc -->
  <title>Qt 4.7: Using QML in C++ Applications</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="narrowsearch"></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://doc.qt.nokia.com">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu" id="narrowmenu"> 
 			<li><a href="#">API Lookup</a> 
 				<ul> 
 					<li><a href="classes.html">Class index</a></li> 
           <li><a href="functions.html">Function index</a></li> 
           <li><a href="modules.html">Modules</a></li> 
           <li><a href="namespaces.html">Namespaces</a></li> 
           <li><a href="qtglobal.html">Global Declarations</a></li> 
           <li><a href="qdeclarativeelements.html">QML elements</a></li> 
 		    </ul> 
 			</li> 
 			<li><a href="#">Qt Topics</a> 
 				<ul> 
 					   <li><a href="qt-basic-concepts.html">Programming with Qt</a></li>  
 					   <li><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li>  
 					   <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li>  
 					   <li><a href="developing-with-qt.html">Cross-platform and Platform-specific</a></li>  
 					   <li><a href="platform-specific.html">Platform-specific info</a></li>  
 					   <li><a href="technology-apis.html">Qt and Key Technologies</a></li>  
 					   <li><a href="best-practices.html">How-To's and Best Practices</a></li>  
 		     </ul> 
 				</li> 
 				<li><a href="#">Examples</a> 
 					<ul> 
 		              <li><a href="all-examples.html">Examples</a></li> 
 		              <li><a href="tutorials.html">Tutorials</a></li> 
 		              <li><a href="demos.html">Demos</a></li> 
 		              <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
 		       </ul> 
 					</li> 
 				</ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search" id="sidebarsearch">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
 <div id="resultdialog"> 
 <a href="#" id="resultclose">Close</a> 
<!-- <p id="resultlinks" class="all"><a href="#" id="showallresults">All</a> | <a href="#" id="showapiresults">API</a> | <a href="#" id="showarticleresults">Articles</a> | <a href="#" id="showexampleresults">Examples</a></p> 
 <p id="searchcount" class="all"><span id="resultcount"></span><span id="apicount"></span><span id="articlecount"></span><span id="examplecount"></span>&nbsp;results:</p> --> 
 <ul id="resultlist" class="all"> 
 </ul> 
 </div> 
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
			   <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
			   <li class="defaultLink"><a href="qtquick.html">Device UIs &amp; Qt Quick</a></li> 
			   <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
			   <li class="defaultLink"><a href="developing-with-qt.html">Cross-platform and Platform-specific</a></li> 
			   <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
			   <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li>Using QML in C++ Applications</li>            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#core-module-classes">Core module classes</a></li>
<li class="level1"><a href="#approaches-to-using-qml-with-c">Approaches to using QML with C++</a></li>
<li class="level2"><a href="#loading-qml-components-from-c">Loading QML components from C++</a></li>
<li class="level3"><a href="#locating-child-objects">Locating child objects</a></li>
<li class="level2"><a href="#embedding-c-objects-into-qml-components">Embedding C++ objects into QML components</a></li>
<li class="level2"><a href="#defining-new-qml-elements">Defining new QML elements</a></li>
<li class="level1"><a href="#exchanging-data-between-qml-and-c">Exchanging data between QML and C++</a></li>
<li class="level2"><a href="#calling-functions">Calling functions</a></li>
<li class="level2"><a href="#receiving-signals">Receiving signals</a></li>
<li class="level2"><a href="#modifying-properties">Modifying properties</a></li>
<li class="level1"><a href="#supported-data-types">Supported data types</a></li>
<li class="level2"><a href="#javascript-arrays-and-objects">JavaScript arrays and objects</a></li>
<li class="level2"><a href="#using-enumerations-of-a-custom-type">Using enumerations of a custom type</a></li>
<li class="level2"><a href="#automatic-type-conversion-from-strings">Automatic type conversion from strings</a></li>
<li class="level1"><a href="#writing-qml-plugins">Writing QML plugins</a></li>
<li class="level1"><a href="#managing-resource-files-with-the-qt-resource-system">Managing resource files with the Qt resource system</a></li>
</ul>
</div>
<h1 class="title">Using QML in C++ Applications</h1>
<span class="subtitle"></span>
<!-- $$$qtbinding.html-description -->
<div class="descr"> <a name="details"></a>
<a name="qtbinding"></a><p>QML is designed to be easily extensible from C++. The classes in the Qt Declarative module allow QML components to be loaded and manipulated from C++, and through Qt's <a href="metaobjects.html">meta-object system</a>, QML and C++ objects can easily communicate through Qt signals and slots. In addition, QML plugins can be written to create reusable QML components for distribution.</p>
<p>You may want to mix QML and C++ for a number of reasons. For example:</p>
<ul>
<li>To use functionality defined in a C++ source (for example, when using a C++ Qt-based data model, or calling functions in a third-party C++ library)</li>
<li>To access functionality in the Qt Declarative module (for example, to dynamically generate images using <a href="qdeclarativeimageprovider.html">QDeclarativeImageProvider</a>)</li>
<li>To write your own QML elements (whether for your applications, or for distribution to others)</li>
</ul>
<p>To use the Qt Declarative module, you must include and link to the module appropriately, as shown on the <a href="qtdeclarative.html">module index page</a>. The <a href="qmlruntime.html">Qt Declarative UI Runtime</a> documentation shows how to build a basic C++ application that uses this module.</p>
<a name="core-module-classes"></a>
<h2>Core module classes</h2>
<p>The Qt Declarative module provides a set of C++ APIs for extending your QML applications from C++ and embedding QML into C++ applications. There are several core classes in the Qt Declarative module that provide the essential capabilities for doing this. These are:</p>
<ul>
<li><a href="qdeclarativeengine.html">QDeclarativeEngine</a>: A QML engine provides the environment for executing QML code. Every application requires at least one engine instance.</li>
<li><a href="qdeclarativecomponent.html">QDeclarativeComponent</a>: A component encapsulates a <a href="qdeclarativedocuments.html">QML document</a>.</li>
<li><a href="qdeclarativecontext.html">QDeclarativeContext</a>: A context allows an application to expose data to the QML components created by an engine.</li>
</ul>
<p>A <a href="qdeclarativeengine.html">QDeclarativeEngine</a> allows the configuration of global settings that apply to all of its QML component instances: for example, the <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> to be used for network communications, and the file path to be used for persistent storage.</p>
<p><a href="qdeclarativecomponent.html">QDeclarativeComponent</a> is used to load QML documents. Each <a href="qdeclarativecomponent.html">QDeclarativeComponent</a> instance represents a single document. A component can be created from the URL or file path of a QML document, or the raw QML code of the document. Component instances are instatiated through the <a href="qdeclarativecomponent.html#create">QDeclarativeComponent::create</a>() method, like this:</p>
<pre class="highlightedCode brush: cpp"> QDeclarativeEngine engine;
 QDeclarativeComponent component(&amp;engine, QUrl::fromLocalFile(&quot;MyRectangle.qml&quot;));
 QObject *rectangleInstance = component.create();

<span class="comment"> // ...</span>
 delete rectangleInstance;</pre>
<p>QML documents can also be loaded using <a href="qdeclarativeview.html">QDeclarativeView</a>. This class provides a convenient <a href="qwidget.html">QWidget</a>-based view for embedding QML components into <a href="qgraphicsview.html">QGraphicsView</a>-based applications. (For other methods of integrating QML into <a href="qwidget.html">QWidget</a>-based applications, see <a href="qml-integration.html">Integrating QML with existing Qt UI code</a>.)</p>
<a name="approaches-to-using-qml-with-c"></a>
<h2>Approaches to using QML with C++</h2>
<p>There are a number of ways to extend your QML application through C++. For example, you could:</p>
<ul>
<li>Load a QML component and manipulate it (or its children) from C++</li>
<li>Embed a C++ object and its properties directly into a QML component (for example, to make a particular C++ object callable from QML, or to replace a dummy list model with a real data set)</li>
<li>Define new QML elements (through <a href="qobject.html">QObject</a>-based C++ classes) and create them directly from your QML code</li>
</ul>
<p>These methods are shown below. Naturally these approaches are not exclusive; you can mix any of these methods throughout your application as appropriate.</p>
<a name="loading-qml-components-from-c"></a>
<h3>Loading QML components from C++</h3>
<p>A QML document can be loaded with <a href="qdeclarativecomponent.html">QDeclarativeComponent</a> or <a href="qdeclarativeview.html">QDeclarativeView</a>. <a href="qdeclarativecomponent.html">QDeclarativeComponent</a> loads a QML component as a C++ object; <a href="qdeclarativeview.html">QDeclarativeView</a> also does this, but additionally loads the QML component directly into a <a href="qgraphicsview.html">QGraphicsView</a>. It is convenient for loading a displayable QML component into a <a href="qwidget.html">QWidget</a>-based application.</p>
<p>For example, suppose there is a <tt>MyItem.qml</tt> file that looks like this:</p>
<pre class="highlightedCode brush: cpp"> import QtQuick 1.0

 Item {
     width: 100; height: 100
 }</pre>
<p>This QML document can be loaded with <a href="qdeclarativecomponent.html">QDeclarativeComponent</a> or <a href="qdeclarativeview.html">QDeclarativeView</a> with the following C++ code. Using a <a href="qdeclarativecomponent.html">QDeclarativeComponent</a> requires calling <a href="qdeclarativecomponent.html#create">QDeclarativeComponent::create</a>() to create a new instance of the component, while a <a href="qdeclarativeview.html">QDeclarativeView</a> automatically creates an instance of the component, which is accessible via <a href="qdeclarativeview.html#rootObject">QDeclarativeView::rootObject</a>():</p>
<table class="generic">
<tr class="odd topAlign"><td ><p><pre class="highlightedCode brush: cpp"><span class="comment"> // Using QDeclarativeComponent</span>
 QDeclarativeEngine engine;
 QDeclarativeComponent component(&amp;engine,
         QUrl::fromLocalFile(&quot;MyItem.qml&quot;));
 QObject *object = component.create();
 ...
 delete object;</pre>
</p></td><td ><p><pre class="highlightedCode brush: cpp"><span class="comment"> // Using QDeclarativeView</span>
 QDeclarativeView view;
 view.setSource(QUrl::fromLocalFile(&quot;MyItem.qml&quot;));
 view.show();
 QObject *object = view.rootObject();</pre>
</p></td></tr>
</table>
<p>This <tt>object</tt> is the instance of the <tt>MyItem.qml</tt> component that has been created. You can now modify the item's properties using <a href="qobject.html#setProperty">QObject::setProperty</a>() or <a href="qdeclarativeproperty.html">QDeclarativeProperty</a>:</p>
<pre class="highlightedCode brush: cpp"> object-&gt;setProperty(&quot;width&quot;, 500);
 QDeclarativeProperty(object, &quot;width&quot;).write(500);</pre>
<p>Alternatively, you can cast the object to its actual type and call functions with compile-time safety. In this case the base object of <tt>MyItem.qml</tt> is an <a href="qml-item.html">Item</a>, which is defined by the <a href="qdeclarativeitem.html">QDeclarativeItem</a> class:</p>
<pre class="highlightedCode brush: cpp"> QDeclarativeItem *item = qobject_cast&lt;QDeclarativeItem*&gt;(object);
 item-&gt;setWidth(500);</pre>
<p>You can also connect to any signals or call functions defined in the component using <a href="qmetaobject.html#invokeMethod">QMetaObject::invokeMethod</a>() and <a href="qobject.html#connect">QObject::connect</a>(). See <a href="#exchanging-data-between-qml-and-c">Exchanging data between QML and C++</a> below for further details.</p>
<a name="locating-child-objects"></a>
<h4>Locating child objects</h4>
<p>QML components are essentially object trees with children that have siblings and their own children. Child objects of QML components can be located using the <a href="qobject.html#objectName-prop">QObject::objectName</a> property with <a href="qobject.html#findChild">QObject::findChild</a>(). For example, if the root item in <tt>MyItem.qml</tt> had a child <a href="qml-rectangle.html">Rectangle</a> item:</p>
<pre class="highlightedCode brush: cpp"> import QtQuick 1.0

 Item {
     width: 100; height: 100

     Rectangle {
         anchors.fill: parent
         objectName: &quot;rect&quot;
     }
 }</pre>
<p>The child could be located like this:</p>
<pre class="highlightedCode brush: cpp"> QObject *rect = object-&gt;findChild&lt;QObject*&gt;(&quot;rect&quot;);
 if (rect)
     rect-&gt;setProperty(&quot;color&quot;, &quot;red&quot;);</pre>
<p>If <tt>objectName</tt> is used inside a delegate of a <a href="qml-listview.html">ListView</a>, <a href="qml-repeater.html">Repeater</a> or some other element that creates multiple instances of its delegates, there will be multiple children with the same <tt>objectName</tt>. In this case, <a href="qobject.html#findChildren">QObject::findChildren</a>() can be used to find all children with a matching <tt>objectName</tt>.</p>
<p><b>Warning:</b> While it is possible to use C++ to access and manipulate QML objects deep into the object tree, we recommend that you do not take this approach outside of application testing and prototyping. One strength of QML and C++ integration is the ability to implement the QML user interface separately from the C++ logic and dataset backend, and this strategy breaks if the C++ side reaches deep into the QML components to manipulate them directly. This would make it difficult to, for example, swap a QML view component for another view, if the new component was missing a required <tt>objectName</tt>. It is better for the C++ implementation to know as little as possible about the QML user interface implementation and the composition of the QML object tree.</p>
<a name="embedding-c-objects-into-qml-components"></a>
<h3>Embedding C++ objects into QML components</h3>
<p>When loading a QML scene into a C++ application, it can be useful to directly embed C++ data into the QML object. <a href="qdeclarativecontext.html">QDeclarativeContext</a> enables this by exposing data to the context of a QML component, allowing data to be injected from C++ into QML.</p>
<p>For example, here is a QML item that refers to a <tt>currentDateTime</tt> value that does not exist in the current scope:</p>
<pre class="highlightedCode brush: cpp"> // MyItem.qml
 import QtQuick 1.0

 Text { text: currentDateTime }</pre>
<p>This <tt>currentDateTime</tt> value can be set directly by the C++ application that loads the QML component, using <a href="qdeclarativecontext.html#setContextProperty">QDeclarativeContext::setContextProperty</a>():</p>
<pre class="highlightedCode brush: cpp"> QDeclarativeView view;
 view.rootContext()-&gt;setContextProperty(&quot;currentDateTime&quot;, QDateTime::currentDateTime());
 view.setSource(QUrl::fromLocalFile(&quot;MyItem.qml&quot;));
 view.show();</pre>
<p>Context properties can hold either <a href="qvariant.html">QVariant</a> or <a href="qobject.html">QObject</a>* values. This means custom C++ objects can also be injected using this approach, and these objects can be modified and read directly in QML. Here, we modify the above example to embed a <a href="qobject.html">QObject</a> instance instead of a <a href="qdatetime.html">QDateTime</a> value, and the QML code invokes a method on the object instance:</p>
<table class="generic">
<tr class="odd topAlign"><td ><p><pre class="highlightedCode brush: cpp"> class ApplicationData : public QObject
 {
     Q_OBJECT
 public:
     Q_INVOKABLE QDateTime getCurrentDateTime() const {
         return QDateTime::currentDateTime();
     }
 };

 int main(int argc, char *argv[]) {
     QApplication app(argc, argv);

     QDeclarativeView view;

     ApplicationData data;
     view.rootContext()-&gt;setContextProperty(&quot;applicationData&quot;, &amp;data);

     view.setSource(QUrl::fromLocalFile(&quot;MyItem.qml&quot;));
     view.show();

     return app.exec();
 }</pre>
</p></td><td ><p><pre class="highlightedCode brush: cpp"> // MyItem.qml
 import QtQuick 1.0

 Text { text: applicationData.getCurrentDateTime() }</pre>
</p></td></tr>
</table>
<p>(Note that date/time values returned from C++ to QML can be formatted through <a href="qml-qt.html#formatDateTime-method">Qt.formatDateTime()</a> and associated functions.)</p>
<p>If the QML item needs to receive signals from the context property, it can connect to them using the <a href="qml-connections.html">Connections</a> element. For example, if <tt>ApplicationData</tt> has a signal named <tt>dataChanged()</tt>, this signal can be connected to using an <tt>onDataChanged</tt> handler within a <a href="qml-connections.html">Connections</a> object:</p>
<pre class="highlightedCode brush: cpp"> Text {
     text: applicationData.getCurrentDateTime()

     Connections {
         target: applicationData
         onDataChanged: console.log(&quot;The application data changed!&quot;)
     }
 }</pre>
<p>Context properties can be useful for using C++ based data models in a QML view. See the <a href="declarative-modelviews-stringlistmodel.html">String ListModel</a>, <a href="declarative-modelviews-objectlistmodel.html">Object ListModel</a> and <a href="declarative-modelviews-abstractitemmodel.html">AbstractItemModel</a> models for respective examples on using <a href="qstringlistmodel.html">QStringListModel</a>, <a href="qobject.html#QObjectList-typedef">QObjectList</a>-based models and <a href="qabstractitemmodel.html">QAbstractItemModel</a> in QML views.</p>
<p>Also see the <a href="qdeclarativecontext.html">QDeclarativeContext</a> documentation for more information.</p>
<a name="defining-new-qml-elements"></a>
<h3>Defining new QML elements</h3>
<p>While new QML elements can be <a href="qml-extending-types.html#defining-new-components">defined in QML</a>, they can also be defined by C++ classes; in fact, many of the core <a href="qdeclarativeelements.html">QML Elements</a> are implemented through C++ classes. When you create a QML object using one of these elements, you are simply creating an instance of a <a href="qobject.html">QObject</a>-based C++ class and setting its properties.</p>
<p>For example, here is an <tt>ImageViewer</tt> class with an <tt>image</tt> URL property:</p>
<pre class="highlightedCode brush: cpp"> #include &lt;QtCore&gt;
 #include &lt;QtDeclarative&gt;

 class ImageViewer : public QDeclarativeItem
 {
     Q_OBJECT
     Q_PROPERTY(QUrl image READ image WRITE setImage NOTIFY imageChanged)

 public:
     void setImage(const QUrl &amp;url);
     QUrl image() const;

 signals:
     void imageChanged();
 };</pre>
<p>Aside from the fact that it inherits <a href="qdeclarativeitem.html">QDeclarativeItem</a>, this is an ordinary class that could exist outside of QML. However, once it is registered with the QML engine using <a href="qdeclarativeengine.html#qmlRegisterType">qmlRegisterType</a>():</p>
<pre class="highlightedCode brush: cpp">     qmlRegisterType&lt;ImageViewer&gt;(&quot;MyLibrary&quot;, 1, 0, &quot;ImageViewer&quot;);</pre>
<p>Then, any QML code loaded by your C++ application or <a href="qdeclarativeextensionplugin.html">plugin</a> can create and manipulate <tt>ImageViewer</tt> objects:</p>
<pre class="highlightedCode brush: cpp"> import MyLibrary 1.0

 ImageViewer { image: &quot;smile.png&quot; }</pre>
<p>Note that custom C++ types do not have to inherit from <a href="qdeclarativeitem.html">QDeclarativeItem</a>; this is only necessary if it is a displayable item. If the item is not displayable, it can simply inherit from <a href="qobject.html">QObject</a>.</p>
<p>For more information on defining new QML elements, see the <a href="qml-extending-tutorial-index.html">Writing QML extensions with C++</a> tutorial and the <a href="qml-extending.html">Extending QML in C++</a> reference documentation.</p>
<a name="exchanging-data-between-qml-and-c"></a>
<h2>Exchanging data between QML and C++</h2>
<p>QML and C++ objects can communicate with one another through signals, slots and property modifications. For a C++ object, any data that is exposed to Qt's <a href="metaobjects.html">Meta-Object System</a> - that is, properties, signals, slots and <a href="qobject.html#Q_INVOKABLE">Q_INVOKABLE</a> methods - become available to QML. On the QML side, all QML object data is automatically made available to the meta-object system and can be accessed from C++.</p>
<a name="calling-functions"></a>
<h3>Calling functions</h3>
<p>QML functions can be called from C++ and vice-versa.</p>
<p>All QML functions are exposed to the meta-object system and can be called using <a href="qmetaobject.html#invokeMethod">QMetaObject::invokeMethod</a>(). Here is a C++ application that uses this to call a QML function:</p>
<table class="generic">
<tr class="odd topAlign"><td ><p><pre class="highlightedCode brush: cpp"> // MyItem.qml
 import QtQuick 1.0

 Item {
     function myQmlFunction(msg) {
         console.log(&quot;Got message:&quot;, msg)
         return &quot;some return value&quot;
     }
 }</pre>
</p></td><td ><p><pre class="highlightedCode brush: cpp"><span class="comment"> // main.cpp</span>
 QDeclarativeEngine engine;
 QDeclarativeComponent component(&amp;engine, &quot;MyItem.qml&quot;);
 QObject *object = component.create();

 QVariant returnedValue;
 QVariant msg = &quot;Hello from C++&quot;;
 QMetaObject::invokeMethod(object, &quot;myQmlFunction&quot;,
         Q_RETURN_ARG(QVariant, returnedValue),
         Q_ARG(QVariant, msg));

 qDebug() &lt;&lt; &quot;QML function returned:&quot; &lt;&lt; returnedValue.toString();
 delete object;</pre>
</p></td></tr>
</table>
<p>Notice the <a href="qmetaobject.html#Q_RETURN_ARG">Q_RETURN_ARG</a>() and <a href="qmetaobject.html#Q_ARG">Q_ARG</a>() arguments for <a href="qmetaobject.html#invokeMethod">QMetaObject::invokeMethod</a>() must be specified as <a href="qvariant.html">QVariant</a> types, as this is the generic data type used for QML functions and return values.</p>
<p>To call a C++ function from QML, the function must be either a Qt slot, or a function marked with the <a href="qobject.html#Q_INVOKABLE">Q_INVOKABLE</a> macro, to be available to QML. In the following example, the QML code invokes methods on the <tt>myObject</tt> object, which has been set using <a href="qdeclarativecontext.html#setContextProperty">QDeclarativeContext::setContextProperty</a>():</p>
<table class="generic">
<tr class="odd topAlign"><td ><p><pre class="highlightedCode brush: cpp"> // MyItem.qml
 import QtQuick 1.0

 Item {
     width: 100; height: 100

     MouseArea {
         anchors.fill: parent
         onClicked: {
             myObject.cppMethod(&quot;Hello from QML&quot;)
             myObject.cppSlot(12345)
         }
     }
 }</pre>
</p></td><td ><p><pre class="highlightedCode brush: cpp"> class MyClass : public QObject
 {
     Q_OBJECT
 public:
     Q_INVOKABLE void cppMethod(const QString &amp;msg) {
         qDebug() &lt;&lt; &quot;Called the C++ method with&quot; &lt;&lt; msg;
     }

 public slots:
     void cppSlot(int number) {
         qDebug() &lt;&lt; &quot;Called the C++ slot with&quot; &lt;&lt; number;
     }
 };

 int main(int argc, char *argv[]) {
     QApplication app(argc, argv);

     QDeclarativeView view;
     MyClass myClass;
     view.rootContext()-&gt;setContextProperty(&quot;myObject&quot;, &amp;myClass);

     view.setSource(QUrl::fromLocalFile(&quot;MyItem.qml&quot;));
     view.show();

     return app.exec();
 }</pre>
</p></td></tr>
</table>
<p>QML supports the calling of overloaded C++ functions. If there are multiple C++ functions with the same name but different arguments, the correct function will be called according to the number and the types of arguments that are provided.</p>
<a name="receiving-signals"></a>
<h3>Receiving signals</h3>
<p>All QML signals are automatically available to C++, and can be connected to using <a href="qobject.html#connect">QObject::connect</a>() like any ordinary Qt C++ signal. In return, any C++ signal can be received by a QML object using <a href="qdeclarativeintroduction.html#signal-handlers">signal handlers</a>.</p>
<p>Here is a QML component with a signal named <tt>qmlSignal</tt>. This signal is connected to a C++ object's slot using <a href="qobject.html#connect">QObject::connect</a>(), so that the <tt>cppSlot()</tt> method is called whenever the <tt>qmlSignal</tt> is emitted:</p>
<table class="generic">
<tr class="odd topAlign"><td ><p><pre class="highlightedCode brush: cpp"> // MyItem.qml
 import QtQuick 1.0

 Item {
     id: item
     width: 100; height: 100

     signal qmlSignal(string msg)

     MouseArea {
         anchors.fill: parent
         onClicked: item.qmlSignal(&quot;Hello from QML&quot;)
     }
 }</pre>
</p></td><td ><p><pre class="highlightedCode brush: cpp"> class MyClass : public QObject
 {
     Q_OBJECT
 public slots:
     void cppSlot(const QString &amp;msg) {
         qDebug() &lt;&lt; &quot;Called the C++ slot with message:&quot; &lt;&lt; msg;
     }
 };

 int main(int argc, char *argv[]) {
     QApplication app(argc, argv);

     QDeclarativeView view(QUrl::fromLocalFile(&quot;MyItem.qml&quot;));
     QObject *item = view.rootObject();

     MyClass myClass;
     QObject::connect(item, SIGNAL(qmlSignal(QString)),
                      &amp;myClass, SLOT(cppSlot(QString)));

     view.show();
     return app.exec();
 }</pre>
</p></td></tr>
</table>
<p>To connect to Qt C++ signals from within QML, use a signal handler with the <tt>on&lt;SignalName&gt;</tt> syntax. If the C++ object is directly creatable from within QML (see <a href="#defining-new-qml-elements">Defining new QML elements</a> above) then the signal handler can be defined within the object declaration. In the following example, the QML code creates a <tt>ImageViewer</tt> object, and the <tt>imageChanged</tt> and <tt>loadingError</tt> signals of the C++ object are connected to through <tt>onImagedChanged</tt> and <tt>onLoadingError</tt> signal handlers in QML:</p>
<table class="generic">
<tr class="odd topAlign"><td ><p><pre class="highlightedCode brush: cpp"> class ImageViewer : public QDeclarativeItem
 {
     Q_OBJECT
     Q_PROPERTY(QUrl image READ image WRITE setImage NOTIFY imageChanged)
 public:
     ...
 signals:
     void imageChanged();
     void loadingError(const QString &amp;errorMsg);
 };</pre>
</p></td><td ><p><pre class="highlightedCode brush: cpp"> ImageViewer {
     onImageChanged: console.log(&quot;Image changed!&quot;)
     onLoadingError: console.log(&quot;Image failed to load:&quot;, errorMsg)
 }</pre>
</p></td></tr>
</table>
<p>(Note that if a signal has been declared as the NOTIFY signal for a property, QML allows it to be received with an <tt>on&lt;Property&gt;Changed</tt> handler even if the signal's name does not follow the <tt>&lt;Property&gt;Changed</tt> naming convention. In the above example, if the &quot;imageChanged&quot; signal was named &quot;imageModified&quot; instead, the <tt>onImageChanged</tt> signal handler would still be called.)</p>
<p>If, however, the object with the signal is not created from within the QML code, and the QML item only has a reference to the created object - for example, if the object was set using <a href="qdeclarativecontext.html#setContextProperty">QDeclarativeContext::setContextProperty</a>() - then the <a href="qml-connections.html">Connections</a> element can be used instead to create the signal handler:</p>
<table class="generic">
<tr class="odd topAlign"><td ><p><pre class="highlightedCode brush: cpp"> ImageViewer viewer;

 QDeclarativeView view;
 view.rootContext()-&gt;setContextProperty(&quot;imageViewer&quot;, &amp;viewer);

 view.setSource(QUrl::fromLocalFile(&quot;MyItem.qml&quot;));
 view.show();</pre>
</p></td><td ><p><pre class="highlightedCode brush: cpp"> // MyItem.qml
 import QtQuick 1.0

 Item {
     Connections {
         target: imageViewer
         onImageChanged: console.log(&quot;Image has changed!&quot;)
     }
 }</pre>
</p></td></tr>
</table>
<a name="modifying-properties"></a>
<h3>Modifying properties</h3>
<p>Any properties declared in a QML object are automatically accessible from C++. Given a QML item like this:</p>
<pre class="highlightedCode brush: cpp"> // MyItem.qml
 import QtQuick 1.0

 Item {
     property int someNumber: 100
 }</pre>
<p>The value of the <tt>someNumber</tt> property can be set and read using <a href="qdeclarativeproperty.html">QDeclarativeProperty</a>, or <a href="qobject.html#setProperty">QObject::setProperty</a>() and <a href="qobject.html#property">QObject::property</a>():</p>
<pre class="highlightedCode brush: cpp"> QDeclarativeEngine engine;
 QDeclarativeComponent component(&amp;engine, &quot;MyItem.qml&quot;);
 QObject *object = component.create();

 qDebug() &lt;&lt; &quot;Property value:&quot; &lt;&lt; QDeclarativeProperty::read(object, &quot;someNumber&quot;).toInt();
 QDeclarativeProperty::write(object, &quot;someNumber&quot;, 5000);

 qDebug() &lt;&lt; &quot;Property value:&quot; &lt;&lt; object-&gt;property(&quot;someNumber&quot;).toInt();
 object-&gt;setProperty(&quot;someNumber&quot;, 100);</pre>
<p>You should always use <a href="qobject.html#setProperty">QObject::setProperty</a>(), <a href="qdeclarativeproperty.html">QDeclarativeProperty</a> or <a href="qmetaproperty.html#write">QMetaProperty::write</a>() to change a QML property value, to ensure the QML engine is made aware of the property change. For example, say you have a custom element <tt>PushButton</tt> with a <tt>buttonText</tt> property that internally reflects the value of a <tt>m_buttonText</tt> member variable. Modifying the member variable directly like this is not a good idea:</p>
<pre class="highlightedCode brush: cpp"> // BAD!
 QDeclarativeComponent component(engine, &quot;MyButton.qml&quot;);
 PushButton *button = qobject_cast&lt;PushButton*&gt;(component.create());
 button-&gt;m_buttonText = &quot;Click me&quot;;</pre>
<p>Since the value is changed directly, this bypasses Qt's <a href="metaobjects.html">meta-object system</a> and the QML engine is not made aware of the property change. This means property bindings to <tt>buttonText</tt> would not be updated, and any <tt>onButtonTextChanged</tt> handlers would not be called.</p>
<a name="properties-cpp"></a><p>Any <a href="properties.html">Qt properties</a> - that is, those declared with the <a href="qobject.html#Q_PROPERTY">Q_PROPERTY</a>() macro - are accessible from QML. Here is a modified version of the <a href="#embedding-c-objects-into-qml-components">earlier example</a> on this page; here, the <tt>ApplicationData</tt> class has a <tt>backgroundColor</tt> property. This property can be written to and read from QML:</p>
<table class="generic">
<tr class="odd topAlign"><td ><p><pre class="highlightedCode brush: cpp"> class ApplicationData : public QObject
 {
     Q_OBJECT
     Q_PROPERTY(QColor backgroundColor
             READ backgroundColor
             WRITE setBackgroundColor
             NOTIFY backgroundColorChanged)

 public:
     void setBackgroundColor(const QColor &amp;c) {
         if (c != m_color) {
             m_color = c;
             emit backgroundColorChanged();
         }
     }

     QColor backgroundColor() const {
         return m_color;
     }

 signals:
     void backgroundColorChanged();

 private:
     QColor m_color;
 };</pre>
</p></td><td ><p><pre class="highlightedCode brush: cpp"> // MyItem.qml
 import QtQuick 1.0

 Rectangle {
     width: 100; height: 100
     color: applicationData.backgroundColor

     MouseArea {
         anchors.fill: parent
         onClicked: applicationData.backgroundColor = &quot;red&quot;
     }
 }</pre>
</p></td></tr>
</table>
<p>Notice the <tt>backgroundColorChanged</tt> signal is declared as the NOTIFY signal for the <tt>backgroundColor</tt> property. If a Qt property does not have an associated NOTIFY signal, the property cannot be used for <a href="propertybinding.html">Property Binding</a> in QML, as the QML engine would not be notified when the value changes. If you are using custom types in QML, make sure their properties have NOTIFY signals so that they can be used in property bindings.</p>
<p>See <a href="qml-extending-tutorial-index.html">Tutorial: Writing QML extensions with C++</a> for further details and examples on using Qt properties with QML.</p>
<a name="supported-data-types"></a>
<h2>Supported data types</h2>
<p>Any C++ data that is used from QML - whether as custom properties, or parameters for signals or functions - must be of a type that is recognizable by QML.</p>
<p>By default, QML recognizes the following data types:</p>
<ul>
<li>bool</li>
<li>unsigned int, int</li>
<li>float, double, qreal</li>
<li><a href="qstring.html">QString</a></li>
<li><a href="qurl.html">QUrl</a></li>
<li><a href="qcolor.html">QColor</a></li>
<li><a href="qdate.html">QDate</a>, <a href="qtime.html">QTime</a>, <a href="qdatetime.html">QDateTime</a></li>
<li><a href="qpoint.html">QPoint</a>, <a href="qpointf.html">QPointF</a></li>
<li><a href="qsize.html">QSize</a>, <a href="qsizef.html">QSizeF</a></li>
<li><a href="qrect.html">QRect</a>, <a href="qrectf.html">QRectF</a></li>
<li><a href="qvariant.html">QVariant</a></li>
<li><a href="qvariant.html#QVariantList-typedef">QVariantList</a>, <a href="qvariant.html#QVariantMap-typedef">QVariantMap</a></li>
<li><a href="qobject.html">QObject</a>*</li>
<li>Enumerations declared with <a href="qobject.html#Q_ENUMS">Q_ENUMS</a>()</li>
</ul>
<p>To allow a custom C++ type to be created or used in QML, the C++ class must be registered as a QML type using <a href="qdeclarativeengine.html#qmlRegisterType">qmlRegisterType</a>(), as shown in the <a href="#defining-new-qml-elements">Defining new QML elements</a> section above.</p>
<a name="javascript-arrays-and-objects"></a>
<h3>JavaScript arrays and objects</h3>
<p>There is built-in support for automatic type conversion between <a href="qvariant.html#QVariantList-typedef">QVariantList</a> and JavaScript arrays, and <a href="qvariant.html#QVariantMap-typedef">QVariantMap</a> and JavaScript objects.</p>
<p>For example, the function defined in QML below left expects two arguments, an array and an object, and prints their contents using the standard JavaScript syntax for array and object item access. The C++ code below right calls this function, passing a <a href="qvariant.html#QVariantList-typedef">QVariantList</a> and a <a href="qvariant.html#QVariantMap-typedef">QVariantMap</a>, which are automatically converted to JavaScript array and object values, repectively:</p>
<table class="generic">
<tr class="odd topAlign"><td ><p><pre class="highlightedCode brush: cpp"> // MyItem.qml
 Item {
     function readValues(anArray, anObject) {
         for (var i=0; i&lt;anArray.length; i++)
             console.log(&quot;Array item:&quot;, anArray[i])

         for (var prop in anObject) {
             console.log(&quot;Object item:&quot;, prop, &quot;=&quot;, anObject[prop])
         }
     }
 }</pre>
</p></td><td ><p><pre class="highlightedCode brush: cpp"><span class="comment"> // C++</span>
 QDeclarativeView view(QUrl::fromLocalFile(&quot;MyItem.qml&quot;));

 QVariantList list;
 list &lt;&lt; 10 &lt;&lt; Qt::green &lt;&lt; &quot;bottles&quot;;

 QVariantMap map;
 map.insert(&quot;language&quot;, &quot;QML&quot;);
 map.insert(&quot;released&quot;, QDate(2010, 9, 21));

 QMetaObject::invokeMethod(view.rootObject(), &quot;readValues&quot;,
         Q_ARG(QVariant, QVariant::fromValue(list)),
         Q_ARG(QVariant, QVariant::fromValue(map)));</pre>
</p></td></tr>
</table>
<p>This produces output like:</p>
<pre class="highlightedCode brush: cpp"> Array item: 10
 Array item: #00ff00
 Array item: bottles
 Object item: language = QML
 Object item: released = Tue Sep 21 2010 00:00:00 GMT+1000 (EST)</pre>
<p>Similarly, if a C++ type uses a <a href="qvariant.html#QVariantList-typedef">QVariantList</a> or <a href="qvariant.html#QVariantMap-typedef">QVariantMap</a> type for a property or method parameter, the value can be created as a JavaScript array or object in the QML side, and is automatically converted to a <a href="qvariant.html#QVariantList-typedef">QVariantList</a> or <a href="qvariant.html#QVariantMap-typedef">QVariantMap</a> when it is passed to C++.</p>
<a name="using-enumerations-of-a-custom-type"></a>
<h3>Using enumerations of a custom type</h3>
<p>To use an enumeration from a custom C++ component, the enumeration must be declared with <a href="qobject.html#Q_ENUMS">Q_ENUMS</a>() to register it with Qt's meta object system. For example, the following C++ type has a <tt>Status</tt> enum:</p>
<pre class="highlightedCode brush: cpp"> class ImageViewer : public QDeclarativeItem
 {
     Q_OBJECT
     Q_ENUMS(Status)
     Q_PROPERTY(Status status READ status NOTIFY statusChanged)
 public:
     enum Status {
         Ready,
         Loading,
         Error
     };

     Status status() const;
 signals:
     void statusChanged();
 };</pre>
<p>Providing the <tt>ImageViewer</tt> class has been registered using <a href="qdeclarativeengine.html#qmlRegisterType">qmlRegisterType</a>(), its <tt>Status</tt> enum can now be used from QML:</p>
<pre class="highlightedCode brush: cpp"> ImageViewer {
     onStatusChanged: {
         if (status == ImageViewer.Ready)
             console.log(&quot;Image viewer is ready!&quot;)
     }
 }</pre>
<p>The C++ type must be registered with QML to use its enums. If your C++ type is not instantiable, it can be registered using <a href="qdeclarativeengine.html#qmlRegisterUncreatableType">qmlRegisterUncreatableType</a>(). To be accessible from QML, the names of enum values must begin with a capital letter.</p>
<p>See the <a href="qml-extending-tutorial-index.html">Writing QML extensions with C++</a> tutorial and the <a href="qml-extending.html">Extending QML in C++</a> reference documentation for more information.</p>
<a name="automatic-type-conversion-from-strings"></a>
<h3>Automatic type conversion from strings</h3>
<p>As a convenience, some basic types can be specified in QML using format strings to make it easier to pass simple values from QML to C++.</p>
<table class="generic">
<thead><tr class="qt-style topAlign"><th >Type</th><th >String format</th><th >Example</th></tr></thead>
<tr class="odd topAlign"><td ><p><a href="qcolor.html">QColor</a></p></td><td ><p>Color name, &quot;#RRGGBB&quot;, &quot;#RRGGBBAA&quot;</p></td><td ><p>&quot;red&quot;, &quot;#ff0000&quot;, &quot;#ff000000&quot;</p></td></tr>
<tr class="even topAlign"><td ><p><a href="qdate.html">QDate</a></p></td><td ><p>&quot;YYYY-MM-DD&quot;</p></td><td ><p>&quot;2010-05-31&quot;</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="qpoint.html">QPoint</a></p></td><td ><p>&quot;x,y&quot;</p></td><td ><p>&quot;10,20&quot;</p></td></tr>
<tr class="even topAlign"><td ><p><a href="qrect.html">QRect</a></p></td><td ><p>&quot;x,y,WidthxHeight&quot;</p></td><td ><p>&quot;50,50,100x100&quot;</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="qsize.html">QSize</a></p></td><td ><p>&quot;WidthxHeight&quot;</p></td><td ><p>&quot;100x200&quot;</p></td></tr>
<tr class="even topAlign"><td ><p><a href="qtime.html">QTime</a></p></td><td ><p>&quot;hh:mm:ss&quot;</p></td><td ><p>&quot;14:22:55&quot;</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="qurl.html">QUrl</a></p></td><td ><p>URL string</p></td><td ><p>&quot;http://www.example.com&quot;</p></td></tr>
<tr class="even topAlign"><td ><p><a href="qvector3d.html">QVector3D</a></p></td><td ><p>&quot;x,y,z&quot;</p></td><td ><p>&quot;0,1,0&quot;</p></td></tr>
<tr class="odd topAlign"><td ><p>Enumeration value</p></td><td ><p>Enum value name</p></td><td ><p>&quot;AlignRight&quot;</p></td></tr>
</table>
<p>(More details on these string formats and types can be found in the <a href="qdeclarativebasictypes.html">basic type documentation</a>.)</p>
<p>These string formats can be used to set QML <tt>property</tt> values and pass arguments to C++ functions. This is demonstrated by various examples on this page; in the above <a href="#properties-cpp">Qt properties example</a>, the <tt>ApplicationData</tt> class has a <tt>backgroundColor</tt> property of a <a href="qcolor.html">QColor</a> type, which is set from the QML code with the string &quot;red&quot; rather rather than an actual <a href="qcolor.html">QColor</a> object.</p>
<p>If it is preferred to pass an explicitly-typed value rather than a string, the global <a href="qml-qt.html#qmlglobalqtobject">Qt object</a> provides convenience functions for creating some of the object types listed above. For example, <a href="qml-qt.html#rgba-method">Qt.rgba()</a> creates a <a href="qcolor.html">QColor</a> value from four RGBA values. The <a href="qcolor.html">QColor</a> returned from this function could be used instead of a string to set a <a href="qcolor.html">QColor</a>-type property or to call a C++ function that requires a <a href="qcolor.html">QColor</a> parameter.</p>
<a name="writing-qml-plugins"></a>
<h2>Writing QML plugins</h2>
<p>The Qt Declarative module includes the <a href="qdeclarativeextensionplugin.html">QDeclarativeExtensionPlugin</a> class, which is an abstract class for writing QML plugins. This allows QML extension types to be dynamically loaded into QML applications.</p>
<p>See the <a href="qdeclarativeextensionplugin.html">QDeclarativeExtensionPlugin</a> documentation and <a href="plugins-howto.html">How to Create Qt Plugins</a> for more details.</p>
<a name="managing-resource-files-with-the-qt-resource-system"></a>
<h2>Managing resource files with the Qt resource system</h2>
<p>The <a href="resources.html">Qt resource system</a> allows resource files to be stored as binary files in an application executable. This can be useful when building a mixed QML/C++ application as it enables QML files (as well as other resources such as images and sound files) to be referred to through the resource system URI scheme rather than relative or absolute paths to filesystem resources. Note, however, that if you use the resource system, the application executable must be re-compiled whenever a QML source file is changed in order to update the resources in the package.</p>
<p>To use the resource system in a mixed QML/C++ application:</p>
<ul>
<li>Create a <tt>.qrc</tt> <a href="resources.html">resource collection file</a> that lists resource files in XML format</li>
<li>From C++, load the main QML file as a resource using the <tt>:/</tt> prefix or as a URL with the <tt>qrc</tt> scheme</li>
</ul>
<p>Once this is done, all files specified by relative paths in QML will be loaded from the resource system instead. Use of the resource system is completely transparent to the QML layer; this means all QML code should refer to resource files using relative paths and should <i>not</i> use the <tt>qrc</tt> scheme. This scheme should only be used from C++ code for referring to resource files.</p>
<p>Here is a application packaged using the <a href="resources.html">Qt resource system</a>. The directory structure looks like this:</p>
<pre class="highlightedCode brush: cpp"> project
     |- example.qrc
     |- main.qml
     |- images
         |- background.png
     |- main.cpp
     |- project.pro</pre>
<p>The <tt>main.qml</tt> and <tt>background.png</tt> files will be packaged as resource files. This is done in the <tt>example.qrc</tt> resource collection file:</p>
<pre class="highlightedCode brush: cpp"> &lt;!DOCTYPE RCC&gt;
 &lt;RCC version=&quot;1.0&quot;&gt;

 &lt;qresource prefix=&quot;/&quot;&gt;
     &lt;file&gt;main.qml&lt;/file&gt;
     &lt;file&gt;images/background.png&lt;/file&gt;
 &lt;/qresource&gt;

 &lt;/RCC&gt;</pre>
<p>Since <tt>background.png</tt> is a resource file, <tt>main.qml</tt> can refer to it using the relative path specified in <tt>example.qrc</tt>:</p>
<pre class="highlightedCode brush: cpp"> // main.qml
 import QtQuick 1.0

 Image { source: &quot;images/background.png&quot; }</pre>
<p>To allow QML to locate resource files correctly, the <tt>main.cpp</tt> loads the main QML file, <tt>main.qml</tt>, as a resource file using the <tt>qrc</tt> scheme:</p>
<pre class="highlightedCode brush: cpp"> int main(int argc, char *argv[])
 {
     QApplication app(argc, argv);

     QDeclarativeView view;
     view.setSource(QUrl(&quot;qrc:/main.qml&quot;));
     view.show();

     return app.exec();
 }</pre>
<p>Finally <tt>project.pro</tt> uses the RESOURCES variable to indicate that <tt>example.qrc</tt> should be used to build the application resources:</p>
<pre class="highlightedCode brush: cpp"> QT += declarative

 SOURCES += main.cpp
 RESOURCES += example.qrc</pre>
<p>See <a href="resources.html">The Qt Resource System</a> for more information.</p>
</div>
<!-- @@@qtbinding.html -->
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
    <br />
    <p>
      Licensees holding valid Qt Commercial licenses may use this document in accordance with the      Qt Commercial License Agreement provided with the Software or, alternatively, in accordance      with the terms contained in a written agreement between you and Nokia.</p>
    <p>
      Alternatively, this document may be used under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU
      Free Documentation License version 1.3</a>
      as published by the Free Software Foundation.</p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback.</p> <p class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
</body>
</html>
